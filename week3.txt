dart의 탄생 배경과 현황
구글이 주류 웹 개발 언어 JS를 대체하기 위해 개발
 -> 빈약한 라이브러리와 신규 언어 학습에 대한 개발자의 피로감으로 인해 외면

다트 기반으로 개발된 크로스 플랫폼 프레임워크 플러터 등장
구글의 적극적인 지원
 -> 밝은 미래 전망

변수
1) 변수
데이터의 저장 공간
dart는 타입 추론 재공 
- 변수 타입을 명시하지 않아도 사용 가능
- 변수 타입을 명시적으로 선언하는 방법도 가능


2) 변수의 초기화

- 초기값이 있는 경우
	자료형 변수명 = 초기값;

- 초기값이 없는 경우
	자료형? 변수명;

? : 다트 언어는 기본적으로 null값을 허용하지 않음 -> ?를 붙여서 변수가 null값을 가질 수 있음을 컴파일러에게 명시
?. : null인식 접근 연산자, null허용 변수의 속성이나 메서드에 접근 시 사용. 
					-> 변수가 null값이면 null을 반환하고 그렇지 않으면 변수에 담긴 데이터를 반환

변수 사용시 변수가 null값인지 확인하는 조건문을 사용하거나 변수명 뒤에 ? 필요.
! : 변수 강제 추출, 변수명 뒤에 사용 시 해당 변수는 null값을 가질 수 없다고 컴파일러에게 명시 
	-> 강제로 값을 추출, 변수 사용 전 변수 초기화 필요.


3) Late 변수
변수 선언부 앞에 late 키워드 사용
null이 될 수 없는 변수를 나중에 초기화 하겠다는 의미의 수식어
-> late로 선언한 변수를 초기화 하지 않으면 런타임 에러 발생
∴ late 변수 사용 시에는 반드시 초기화 이후에 사용해야 하며 null이 올 수 없는 명확한 시점에 사용.


4) Final, Const
변수 선언 시 초기화 이후 재할당 불가능한 변수를 의미
모듈에서 사용 시 차이 발생
final : 변수 선언 후 값을 한 번만 할당 가능
const : 컴파일 시점에 값이 결정, 이 후 재할당 불가능 -> 상수값으로 치환


5) 내장 변수 타입
int, double (숫자)

String (문자열)

bool (참/거짓)

List (리스트)
데이터를 특정 규칙에 따라 순서대로 정렬하여 변수에 적재
- 정적 리스트 : 초기화 시 크기를 정의하여 크기가 불변
	var 리스트명 = List<자료형>.filled(리스트 크기, 초기값, 옵션);
- 가변 리스트 : 크기가 유동적이며 요소의 추가, 수정, 삭제 자유
	var 리스트명 = <자료형>[요소1, 요소2, 요소3, ...];
	var 리스트명 = [요소1, 요소2, 요소3, ...]
	var 리스트명 = List.empty(growable:true); -> 자료형의 명시가 없으므로 다양한 타입의 요소를 추가 가능 (동적 타입)
	var 리스트명 = List<자료형>.filled(초기 크기, 초기값, growable:true);
- 원하는 만큼의 리스트 생성
	var 리스트명 = List.generate(100, (index)=>'samle$index');
- 리스트 내부 요소에 접근하는 방법은 타 언어의 리스트와 유사
인덱스 번호로 접근, add(), insert(), remove(), where(), ...

Set (중복 불가 리스트)
Set은 리스트가 아닌 데이터 중복을 허용하지 않는 자료 구저
- 선언  
Set<자료형> Set명 = {요소1, 요소2, 요소3, ...};
	-> 중복되는 값을 삽입해도 자동으로 삭제
Set<자료형> Set명 = { };
var Set명 = <자료형>{ };

var 변수명 = { } => Map타입으로 초기화

- 사용 방법은 리스트와 유사

Map (키/값)
키와 값으로 이루어진 자료구조
서로 다른 종류의 데이터를 한 번에 관리
- 초기화
// 타입 추론을 통한 초기화
var 변수명 = {
	"키1": "값1",
	"키2": "값2",
	"키3": "값3",
}

// 타입을 명시하여 초기화
Map<키 타입, 값 타입> 변수명 = {
	"키1": "값1",
	"키2": "값2",
	"키3": "값3",
}

// 빈 상태로 초기화
Map<키 타입, 값 타입> 변수명 = { };

// 타입 추론을 통해 빈 상태로 초기화
var 변수명 = <키 타입, 값 타입>{ };
 -> 키와 값의 타입 명시 필요, 생략 시 Set타입으로 선언

- 요소에 접근 시에는 인덱스 번호 대신 키를 사용

enum (열거형)
연관된 상숫값을 그룹으로 묶어 코드의 가독성 향상을 위해 사용
- 선언
enum 열거명{
	상숫값 1,
	상숫값 2,
}

- 호출
열거명.변수명;
변수명.상숫값 -> 변수처럼 사용 가능, switch문에 적합

- enum확장
switch문을 통해 호출하던 값을 각 enum에 적재 가능
ex) 색상
선언
enum ColorType {
	RED(Colors.red),
	YELLOW(Colors.yellow),
	BLUE(Colors.blue);

	const ColorType(this.colorValue);
	final Color colorValue;
}

사용
Widget textWidget(ColorType colortype) {
	return Text(
		style: TextStyle(color: colorType.colorValue),
	);
}

6) 연산자
두 수나 값을 연산하거나 변환하는 기호
산술 연산자 ( +, -, *, /, % )
비교 연산자 ( <, <=, ==, =>, >, != )
증감 연산자 ( ++, -- )
대입 연산자 ( =, +=, -=, *=, /=, %= )
논리 연산자 ( ||, && )
조건 연산자 ( ??, ?: )

- ?? : null 병합 연산자
이 연산자는 앞의 값이 null이면 뒤의 값을 사용
값1??값2

- ?: : 삼항 연산자
조건식 ? 값1 : 값2

7) 분기와 반복문
- 분기
if / else
switch / case

-반복문
for
forEach
for-in
while
do-while








